If you use the sandbox attribute on your iframe:

<iframe src="/flights" sandbox></iframe>
Then all bets are off â€” youâ€™ve intentionally isolated it, even if itâ€™s same-origin.


To loosen restrictions:

<iframe src="/flights" sandbox="allow-scripts allow-same-origin"></iframe>

Now scripts run, and same-origin access is allowed.

1. Embedding untrusted third-party content

Example:
You show user-generated HTML, ads, or analytics dashboards from external providers.

Without sandbox:

Malicious JS inside iframe can run in your origin (if same-origin).

It can steal cookies, tokens, or manipulate your DOM.

With sandbox:

It canâ€™t execute scripts, submit forms, or navigate the top window (unless you explicitly allow it).

<iframe src="https://ads.example.com" sandbox></iframe>
ğŸ’¥ Boom â€” instant containment. Even if their code is malicious, your main app stays safe.


Say your site has a live code editor (like CodePen, StackBlitz, or your in-house playground).
Users can type arbitrary HTML, JS, and CSS â€” thatâ€™s dangerous.
So you render their code in a sandboxed iframe:
<iframe sandbox="allow-scripts"></iframe>

Now scripts run inside the iframe, but:

They canâ€™t touch your parent window.

They canâ€™t open popups.

They canâ€™t change cookies or localStorage.

They canâ€™t make network calls with your credentials.

âœ… Perfect for teaching tools, code previewers, markdown renderers.


3. Isolating micro-frontends or legacy modules

If youâ€™re working on a large frontend system (say, flight booking dashboard or travel admin portal) and integrating legacy apps or third-party panels, sandboxing helps:

<iframe src="/legacy-dashboard" sandbox="allow-scripts allow-same-origin"></iframe>


This ensures the legacy app:

Can run JS,

Can access its own API (same-origin),

But canâ€™t mess with your top-level DOM or cookies.

Think of it as â€œlet the old app live in the backyard, but donâ€™t give it house keys.â€