ğŸ”· Interview-Grade Explanation of Webpack & State Sharing in Microfrontends

Webpack is a powerful module bundler that transforms, optimizes, and packages application code into deployable bundles. In a microfrontend architectureâ€”where different parts of the UI are built and deployed independentlyâ€”Webpack enables seamless integration through a feature called Module Federation. Module Federation allows multiple, separately compiled frontend applications to dynamically share code and dependencies at runtime, rather than at build time. It essentially turns each microfrontend into a container that can expose modules for other applications to consume, or import remote modules exposed by other containers. These modules are loaded over the network using remoteEntry.js files, allowing the host application to fetch and execute code from different URLs, without bundling them ahead of time. Webpack also ensures singleton sharing of core libraries like React, so all microfrontends use the same runtime instance, preventing duplication and React hook violations.

When it comes to state sharing, Webpack itself doesnâ€™t pass state; it enables multiple microfrontends to load the same instance of a shared module. We place global state logic (like React Context or Zustand store) inside a shared package (e.g., shared-lib) and mark it as a singleton in Module Federation configuration. This forces Webpack to ensure that the host and all remotes use the exact same copy of the shared state module at runtime. Since they all import the same instance, any state change (like user login or theme update) is immediately reflected across all microfrontends because they reference the same in-memory object inside the browser. No messaging system or API is needed; the shared module acts as a single source of truth that is live and reactive. This approach ensures that authentication status, user data, and global UI state remain synchronized across independently deployed microfrontends, while still allowing each app to be developed and deployed autonomously.

ğŸ¯ Key Takeaway (to end your answer powerfully):

â€œWebpack enables runtime integration of independently deployed frontends and guarantees shared dependencies by using Module Federation. By exposing a shared state container as a singleton module, all microfrontends reference the same in-memory state, achieving real-time state synchronization across federated apps without tight coupling.â€

ğŸš€ Bonus Tip for Interview:

If they ask a follow-up question like â€œHow is state kept in sync without events or APIs?â€, you can respond:

â€œBecause Module Federation shares live JavaScript module instances, not copies. So when one microfrontend updates the global store, that mutation happens on the same object reference that other apps are also using.â€

                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚      Backend (API)       â”‚
                          â”‚ Issues JWT Tokens        â”‚
                          â”‚ (access + refresh)       â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
                                       â”‚
                    HTTP Requests + Shared Auth Context
                                       â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                          HOST APP (Shell)                        â”‚
     â”‚   - Loads microfrontends dynamically using Module Federation     â”‚
     â”‚   - Wraps whole app with <AuthProvider>                          â”‚
     â”‚   - Provides global state & routing                              â”‚
     â”‚                                                                  â”‚
     â”‚   Import remotes at runtime:                                     â”‚
     â”‚   dashboardApp@http://localhost:3001/remoteEntry.js             â”‚
     â”‚   authApp@http://localhost:3002/remoteEntry.js                  â”‚
     â”‚                                                                  â”‚
     â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
     â”‚    â”‚    Shared Module (shared-lib)                          â”‚    â”‚
     â”‚    â”‚    - Contains AuthContext & useReducer global store    â”‚    â”‚
     â”‚    â”‚    - Marked as singleton in Module Federation config   â”‚    â”‚
     â”‚    â”‚    - Lives once in memory, used by ALL apps            â”‚    â”‚
     â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
       Loaded via Webpack Runtime   â”‚ Shared State via Same Memory
                                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                 Microfrontend: AuthApp              â”‚
        â”‚ - Exposes <Auth /> Login Component                  â”‚
        â”‚ - Calls login API, receives tokens                 â”‚
        â”‚ - Calls shared-lib.login() to update global state  â”‚
        â”‚ - Does NOT own global state, only uses it          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              Microfrontend: DashboardApp             â”‚
        â”‚ - Loads user info via apiFetch() from shared-lib     â”‚
        â”‚ - Automatically receives updated global state         â”‚
        â”‚ - If token expires, auto-refresh or logout triggers   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â€œWebpack Module Federation lets each microfrontend be built and deployed independently, but still loaded dynamically at runtime by the host. Microfrontends are not bundled together; instead, they are fetched remotely using URLs that point to remoteEntry.js files. Webpack uses a shared dependency graph so libraries like React or a custom shared-lib are not duplicated â€” they are treated as singletons. This means that if we export a global state container (like a React Context with useReducer) from the shared-lib and configure it as a shared singleton, all microfrontends consume the same live instance in memory. When the Auth microfrontend logs in and updates state, the Dashboard microfrontend instantly reflects the user data because both are referencing the same JavaScript object instance. This achieves real-time state synchronization across independently deployed apps â€” without iframes, without events, and without REST API polling.â€

