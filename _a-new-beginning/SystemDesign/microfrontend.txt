ğŸ”· Interview-Grade Explanation of Webpack & State Sharing in Microfrontends

Webpack is a powerful module bundler that transforms, optimizes, and packages application code into deployable bundles. In a microfrontend architectureâ€”where different parts of the UI are built and deployed independentlyâ€”Webpack enables seamless integration through a feature called Module Federation. Module Federation allows multiple, separately compiled frontend applications to dynamically share code and dependencies at runtime, rather than at build time. It essentially turns each microfrontend into a container that can expose modules for other applications to consume, or import remote modules exposed by other containers. These modules are loaded over the network using remoteEntry.js files, allowing the host application to fetch and execute code from different URLs, without bundling them ahead of time. Webpack also ensures singleton sharing of core libraries like React, so all microfrontends use the same runtime instance, preventing duplication and React hook violations.

When it comes to state sharing, Webpack itself doesnâ€™t pass state; it enables multiple microfrontends to load the same instance of a shared module. We place global state logic (like React Context or Zustand store) inside a shared package (e.g., shared-lib) and mark it as a singleton in Module Federation configuration. This forces Webpack to ensure that the host and all remotes use the exact same copy of the shared state module at runtime. Since they all import the same instance, any state change (like user login or theme update) is immediately reflected across all microfrontends because they reference the same in-memory object inside the browser. No messaging system or API is needed; the shared module acts as a single source of truth that is live and reactive. This approach ensures that authentication status, user data, and global UI state remain synchronized across independently deployed microfrontends, while still allowing each app to be developed and deployed autonomously.

ğŸ¯ Key Takeaway (to end your answer powerfully):

â€œWebpack enables runtime integration of independently deployed frontends and guarantees shared dependencies by using Module Federation. By exposing a shared state container as a singleton module, all microfrontends reference the same in-memory state, achieving real-time state synchronization across federated apps without tight coupling.â€

ğŸš€ Bonus Tip for Interview:

If they ask a follow-up question like â€œHow is state kept in sync without events or APIs?â€, you can respond:

â€œBecause Module Federation shares live JavaScript module instances, not copies. So when one microfrontend updates the global store, that mutation happens on the same object reference that other apps are also using.â€

                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚      Backend (API)       â”‚
                          â”‚ Issues JWT Tokens        â”‚
                          â”‚ (access + refresh)       â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
                                       â”‚
                    HTTP Requests + Shared Auth Context
                                       â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                          HOST APP (Shell)                        â”‚
     â”‚   - Loads microfrontends dynamically using Module Federation     â”‚
     â”‚   - Wraps whole app with <AuthProvider>                          â”‚
     â”‚   - Provides global state & routing                              â”‚
     â”‚                                                                  â”‚
     â”‚   Import remotes at runtime:                                     â”‚
     â”‚   dashboardApp@http://localhost:3001/remoteEntry.js             â”‚
     â”‚   authApp@http://localhost:3002/remoteEntry.js                  â”‚
     â”‚                                                                  â”‚
     â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
     â”‚    â”‚    Shared Module (shared-lib)                          â”‚    â”‚
     â”‚    â”‚    - Contains AuthContext & useReducer global store    â”‚    â”‚
     â”‚    â”‚    - Marked as singleton in Module Federation config   â”‚    â”‚
     â”‚    â”‚    - Lives once in memory, used by ALL apps            â”‚    â”‚
     â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
       Loaded via Webpack Runtime   â”‚ Shared State via Same Memory
                                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                 Microfrontend: AuthApp              â”‚
        â”‚ - Exposes <Auth /> Login Component                  â”‚
        â”‚ - Calls login API, receives tokens                 â”‚
        â”‚ - Calls shared-lib.login() to update global state  â”‚
        â”‚ - Does NOT own global state, only uses it          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              Microfrontend: DashboardApp             â”‚
        â”‚ - Loads user info via apiFetch() from shared-lib     â”‚
        â”‚ - Automatically receives updated global state         â”‚
        â”‚ - If token expires, auto-refresh or logout triggers   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â€œWebpack Module Federation lets each microfrontend be built and deployed independently, but still loaded dynamically at runtime by the host. Microfrontends are not bundled together; instead, they are fetched remotely using URLs that point to remoteEntry.js files. Webpack uses a shared dependency graph so libraries like React or a custom shared-lib are not duplicated â€” they are treated as singletons. This means that if we export a global state container (like a React Context with useReducer) from the shared-lib and configure it as a shared singleton, all microfrontends consume the same live instance in memory. When the Auth microfrontend logs in and updates state, the Dashboard microfrontend instantly reflects the user data because both are referencing the same JavaScript object instance. This achieves real-time state synchronization across independently deployed apps â€” without iframes, without events, and without REST API polling.â€



ğŸš€ Microfrontend Architecture with Webpack Module Federation, Shared State, and JWT Authentication (Complete Summary)
ğŸ§  Architecture Overview
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚        Backend API Server      â”‚
                      â”‚ Auth (JWT Access + Refresh)    â”‚
                      â”‚ Issues Tokens / Validates User â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â–²
                                   â”‚ (HTTP / Fetch)
                                   â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                     HOST CONTAINER (Frontend-App)        â”‚
        â”‚   - Loads remote MFEs at runtime using Module Federation â”‚
        â”‚   - Wraps app with AuthProvider (global auth context)    â”‚
        â”‚   - Contains navigation and routing                     â”‚
        â”‚   - Provides global state & shared utilities            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ Shared Singleton       â”‚ Runtime Loaded Remotes
                  â”‚                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Dashboard-App        â”‚    â”‚          Auth-App              â”‚
â”‚  (Remote Microfrontend)      â”‚    â”‚  (Remote Microfrontend)        â”‚
â”‚  Displays protected content  â”‚    â”‚  Handles Login / Logout        â”‚
â”‚  Consumes shared state       â”‚    â”‚  Updates shared global state   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


âœ… Each microfrontend is independently deployable
âœ… They are integrated dynamically at runtime via Webpack Module Federation
âœ… A shared global state is provided by a federated shared-lib so all apps use same in-memory store
âœ… Authentication is implemented via JWT Access Token + Refresh Token using secure HttpOnly cookies

ğŸ“¦ 1. Host Webpack Config (Module Federation)
// webpack.config.js (Host)
new ModuleFederationPlugin({
  name: "host",
  filename: "remoteEntry.js",
  remotes: {
    authApp: "authApp@http://localhost:3001/remoteEntry.js",
    dashboardApp: "dashboardApp@http://localhost:3002/remoteEntry.js",
  },
  shared: {
    react: { singleton: true, requiredVersion: "^18.2.0" },
    "react-dom": { singleton: true, requiredVersion: "^18.2.0" },
    "shared-lib": { singleton: true }, // ğŸ”¥ shared state management
  }
});

ğŸ“¦ 2. Remote Webpack Config Example (Dashboard App)
// webpack.config.js (Dashboard Remote)
new ModuleFederationPlugin({
  name: "dashboardApp",
  filename: "remoteEntry.js",
  exposes: {
    "./Dashboard": "./src/Dashboard.jsx"
  },
  shared: {
    react: { singleton: true },
    "react-dom": { singleton: true },
    "shared-lib": { singleton: true }
  }
});

ğŸ“¦ 3. Shared Global State via Context API (in shared-lib)
// shared-lib/authContext.js
import React, { createContext, useReducer, useContext } from 'react';

const AuthContext = createContext();

const initialState = { user: null, accessToken: null };

function authReducer(state, action) {
  switch (action.type) {
    case 'LOGIN':
      return { user: action.payload.user, accessToken: action.payload.accessToken };
    case 'LOGOUT':
      return { user: null, accessToken: null };
    default:
      return state;
  }
}

let globalState = { ...initialState, login: () => {}, logout: () => {} };

export function AuthProvider({ children }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  const login = (user, accessToken) => dispatch({ type: 'LOGIN', payload: { user, accessToken } });
  const logout = () => dispatch({ type: 'LOGOUT' });

  globalState = { ...state, login, logout };

  return (
    <AuthContext.Provider value={{ ...state, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() { return useContext(AuthContext); }
export function getAuthState() { return globalState; }

ğŸŒ 4. Global API Fetch with Auto Refresh Logic
// shared-lib/fetchClient.js
import { getAuthState } from './authContext';

let onUnauthorized;

export function setUnauthorizedHandler(fn) {
  onUnauthorized = fn;
}

async function fetchWithAuth(url, options = {}) {
  const { accessToken } = getAuthState();
  const headers = options.headers || {};
  if (accessToken) headers['Authorization'] = `Bearer ${accessToken}`;
  return fetch(`http://localhost:5000${url}`, { ...options, headers, credentials: 'include' });
}

export async function apiFetch(url, options = {}) {
  let res = await fetchWithAuth(url, options);

  // Auto refresh
  if (res.status === 401) {
    const refreshRes = await fetch(`http://localhost:5000/api/auth/refresh`, { method: 'POST', credentials: 'include' });
    if (!refreshRes.ok) { onUnauthorized && onUnauthorized(); throw new Error('Logged out'); }
    const data = await refreshRes.json();
    const { login } = getAuthState();
    login(data.user, data.accessToken);
    res = await fetchWithAuth(url, options); // retry original req
  }

  if (!res.ok) throw new Error('Network error');
  return res.json();
}

ğŸ” 5. Backend Authentication Flow (Access + Refresh Token)
app.post("/api/auth/login", (req, res) => {
  const user = { id: "u1", name: "Sumit" }; // mock user
  const accessToken = jwt.sign(user, ACCESS_SECRET, { expiresIn: "15s" });
  const refreshToken = jwt.sign({ id: user.id }, REFRESH_SECRET, { expiresIn: "30s" });

  res.cookie("refreshToken", refreshToken, {
    httpOnly: true,
    sameSite: "lax",
    path: "/",
    maxAge: 30 * 1000
  });

  res.json({ user, accessToken });
});

app.post("/api/auth/refresh", (req, res) => {
  const { refreshToken } = req.cookies;
  if (!refreshToken) return res.status(401).json({ error: "Missing refresh token" });

  try {
    const payload = jwt.verify(refreshToken, REFRESH_SECRET);
    const user = { id: payload.id, name: "Sumit" };
    const newAccessToken = jwt.sign(user, ACCESS_SECRET, { expiresIn: "15s" });
    return res.json({ user, accessToken: newAccessToken });
  } catch {
    return res.status(403).json({ error: "Invalid refresh token" });
  }
});

ğŸ§© 6. Host App Bootstrapping the Microfrontends & State
// frontend-app/bootstrap.jsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { BrowserRouter, useNavigate } from 'react-router-dom';
import { AuthProvider, useAuth } from 'shared-lib';
import { setUnauthorizedHandler } from 'shared-lib';
import App from './App';

function GlobalWrapper() {
  const { logout } = useAuth();
  const navigate = useNavigate();

  React.useEffect(() => {
    setUnauthorizedHandler(() => {
      logout();
      navigate('/login');
    });
  }, []);

  return <App />;
}

createRoot(document.getElementById('root')).render(
  <AuthProvider>
    <BrowserRouter>
      <GlobalWrapper />
    </BrowserRouter>
  </AuthProvider>
);

ğŸ¯ Core Concepts to Remember for Interview
Feature	Purpose
Module Federation	Loads remote apps at runtime, without bundling them at build time
Singleton Shared Modules	Ensures only one instance of React and shared state is used across all MFEs
Auth Flow	Access token used for API calls; refresh token stored in HttpOnly cookie for silent token renewal
apiFetch Wrapper	Central place to attach tokens, auto-refresh, and handle session expiration
Global State via shared-lib	Context API with useReducer shared across MFEs as a single JS instance
ğŸš€ Final Explanation (Interview Version)

â€œIn our microfrontend architecture, each frontend is independently built and deployed, but integrated at runtime using Webpack Module Federation. We share a global state and authentication system by exposing a federated singleton module that contains a React Context with useReducer. This ensures all microfrontends operate over the same in-memory state, enabling seamless communication without prop drilling or event buses. Authentication uses a secure dual-token strategy: a short-lived access token in memory and a long-lived refresh token stored in an HttpOnly cookie. When the access token expires, our global fetch wrapper automatically calls a refresh endpoint, updates state, and retries the request, keeping the user session alive and synchronized across microfrontends.â€