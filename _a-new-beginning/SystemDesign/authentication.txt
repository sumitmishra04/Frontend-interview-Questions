AUTHENTICATION::
SSO:
SSO (Single Sign-On) is an authentication method that allows a user to log in once and gain access to multiple applications or services without logging in again.
Why itâ€™s used:
Better user experience (no repeated logins)
Centralized authentication
More secure: passwords are not shared with every service

How SSO Works (Conceptually)
There are a few protocols used for SSO:
Protocol	Description
SAML	XML-based, used in enterprise apps
OAuth 2.0 / OpenID Connect (OIDC)	Token-based, widely used in modern web/mobile apps
JWT	JSON Web Tokens, often combined with OAuth/OIDC

Basic Flow (OAuth 2.0 / OIDC style):
User clicks Login on App A.
App A redirects to Identity Provider (IdP) (Google, Auth0, Okta, etc.).
User authenticates at IdP.
IdP returns a token (JWT or OAuth token) to App A.
App A validates the token and logs in the user.
The token can be used to access other apps in the SSO ecosystem.

JWT 
1. neevr store password in plain text. It must be encrypted using bcrypt package. When checking, the user's input password, that must also be encrypted and then compared.
2. password must be sent through body as communication is encrypted usin https.
3. we send jwt as headers {"x-access-token": Bearer token}
this token can be fetched from cookies or state by passing {withCredentials: true} in axios options. this then helps automatic inclusion of cookie in the req to server.
4. 401 unauthenticated and 403 for forbiddeden(unauthorised)
A JWT is composed of 3 parts:
header.payload.signature
// header
{
  "alg": "HS256",
  "typ": "JWT"
}
// payload
{
  "sub": "1234567890",
  "name": "Sumit",
  "iat": 1697000000,
  "exp": 1697604800
}
// signature = HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
1ï¸âƒ£ JWT Delivery to Browser

After a successful login (OAuth flow, or your backend authenticates the user), the JWT can be sent to the browser in two main ways:

Option A: In Response Body
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}


Browser receives token via AJAX (fetch/axios).

You can store it in memory.

Example:

const res = await fetch('/login', { method: 'POST', body: JSON.stringify({ username, password }) });
const data = await res.json();
const token = data.token;

// store in memory or sessionStorage
sessionStorage.setItem('jwt', token);


Pros: Easy to read from JS.
Cons: Vulnerable to XSS attacks if malicious scripts run on your page.

Option B: HTTP-Only Secure Cookie

Backend sets the JWT in a cookie:

Set-Cookie: jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...; HttpOnly; Secure; SameSite=Strict


Browser automatically sends this cookie with requests.

Cannot be read by JS (document.cookie wonâ€™t work).

Pros: Safer â€” protected from XSS.
Cons: Need to handle CSRF attacks carefully.

2ï¸âƒ£ Using JWT in Requests

If stored in JS-accessible storage:

const token = sessionStorage.getItem('jwt');

fetch('/api/orders', {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${token}`,
  }
});


The server reads the Authorization header, verifies the token, and returns data.

If stored in HTTP-only cookie:

fetch('/api/orders', {
  method: 'GET',
  credentials: 'include' // important for cookies
});
Browser automatically sends the cookie.
Server verifies the token from the cookie.

3ï¸âƒ£ Lifecycle & Expiration

JWT usually has an expiry (exp) claim.
When expired, you either:
Ask the user to log in again
Use a refresh token (long-lived token) to get a new JWT
ðŸ”‘ TL;DR
Method	How Browser Accesses	Pros	Cons
LocalStorage / sessionStorage	sessionStorage.getItem('jwt')	Easy to use in JS	Vulnerable to XSS
HTTP-Only Cookie	Sent automatically with requests	Protected from XSS	Need CSRF protection

Best practice: For production apps, use HTTP-only secure cookies. If you must use localStorage, make sure your app is free of XSS vulnerabilities.

const express = require('express');
const jwt = require('jsonwebtoken');
const cookieParser = require('cookie-parser');
const bodyParser = require('body-parser');

const app = express();
app.use(cookieParser());
app.use(bodyParser.json());

const JWT_SECRET = 'your_secret_key'; // store securely in env variables

// Dummy user for demo
const USER = {
  username: 'sumit',
  password: '12345',
  name: 'Sumit'
};

app.post('/login', (req, res) => {
  const { username, password } = req.body;

  if (username === USER.username && password === USER.password) {
    const token = jwt.sign({ username: USER.username, name: USER.name }, JWT_SECRET, { expiresIn: '1h' });

    // Set token in HTTP-only cookie
    res.cookie('jwt', token, {
      httpOnly: true,
      secure: false, // set to true in production (HTTPS)
      sameSite: 'Strict'
    });

    return res.json({ message: 'Login successful' });
  }

  res.status(401).json({ message: 'Invalid credentials' });
});

// Protected route
app.get('/profile', (req, res) => {
  const token = req.cookies.jwt;
  if (!token) return res.status(401).json({ message: 'Not authenticated' });

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    res.json({ user: decoded });
  } catch (err) {
    res.status(401).json({ message: 'Token invalid or expired' });
  }
});

app.listen(4000, () => console.log('Server running on http://localhost:4000'));


// App.jsx
import React, { useState } from 'react';

function App() {
  const [user, setUser] = useState(null);
  const [message, setMessage] = useState('');

  const handleLogin = async () => {
    const res = await fetch('http://localhost:4000/login', {
      method: 'POST',
      credentials: 'include', // important to send/receive cookies
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username: 'sumit', password: '12345' })
    });

    const data = await res.json();
    setMessage(data.message);
  };

  const fetchProfile = async () => {
    const res = await fetch('http://localhost:4000/profile', {
      method: 'GET',
      credentials: 'include' // send cookie automatically
    });
    const data = await res.json();
    setUser(data.user);
  };

  return (
    <div>
      <h1>React + Express JWT Example</h1>
      <button onClick={handleLogin}>Login</button>
      <button onClick={fetchProfile}>Get Profile</button>
      <p>{message}</p>
      {user && <pre>{JSON.stringify(user, null, 2)}</pre>}
    </div>
  );
}

export default App;


COOKIES::
A cookie is a small piece of data stored in the browser and sent automatically with every HTTP request to the domain that set it.
Set-Cookie: jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...; Path=/; Expires=Fri, 11 Oct 2025 18:00:00 GMT
res.cookie('jwt', token, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production', // HTTPS only in prod
  sameSite: 'Strict',
  path: '/',
  maxAge: 60 * 60 * 1000 // 1 hour
})

2ï¸âƒ£ Important Cookie Attributes for Security
Attribute	Purpose	Security Notes
HttpOnly	JS cannot access this cookie (document.cookie)	Prevents XSS from stealing JWTs
Secure	Cookie only sent over HTTPS	Prevents sending token in plaintext over HTTP
SameSite	Controls cross-site sending	Strict â†’ only same-site requests; Lax â†’ allows top-level navigation; None â†’ cross-site allowed but must use Secure
Domain	Limits cookie to a specific domain	Can be used for subdomain sharing
Path	Limits cookie to a specific path	e.g., /api â†’ cookie sent only for /api/* requests
Expires / Max-Age	Defines lifetime of the cookie	Shorter lifetimes reduce risk of token misuse

ðŸ’¡ Key Takeaways:
HttpOnly + Secure + SameSite â†’ minimum for auth cookies.
Avoid storing sensitive data in localStorage if you can use cookies.
JWT inside a cookie is safer than storing JWT in JS-accessible storage.
Consider short-lived JWTs + refresh tokens for long sessions.


Typical Flow

User logs in

Server sends back access token and refresh token

Frontend stores access token in memory

Not in localStorage (for security)

User makes requests

Access token validates user

Access token expires (automatic timeout)

Frontend silently uses refresh token

Requests a new access token without user logging in again

User continues seamlessly

They donâ€™t even know it expired in the background


How Access & Refresh Tokens Work in Real Time
ðŸ“Œ Assume:

Access Token lifespan: 30 seconds

Refresh Token lifespan: 7 days

â±ï¸ Timeline Example (Like you described)
ðŸŸ¢ 0 â€“ 30 seconds

You log in and receive:

AccessToken1 (valid for 30s)

RefreshToken1 (valid 7 days, stored securely)

You make 4 API calls â†’ all use AccessToken1 âœ…

ðŸ”´ At 31 seconds

AccessToken1 expires

You make another API request

The backend says: âŒ 401 Unauthorized (token expired)

ðŸ”„ Silent Refresh Happens

Frontend uses RefreshToken1 (automatically sent via HTTP-only cookie)

Sends a refresh request: /auth/refresh

Backend verifies refresh token and issues a new AccessToken2

Frontend retries your last request with AccessToken2

âœ… You continue using the app without interruption or login prompt

â³ At 7 days

RefreshToken1 expires

The user makes a new request â†’ refresh fails

Frontend clears auth state and redirects user to login ðŸ”’

User logs in again to get new Access+Refresh tokens


ðŸ”¥ Phase 1 Simplification

Only Access Token

No refresh token yet

Login gives token

Token stored in React Context

Authenticated API calls use token from context

Logout clears token

If token expires â†’ user is simply logged out


User logs in â†’
 Backend returns:
   - accessToken in response body
   - refreshToken in HttpOnly cookie
Frontend stores accessToken in memory
|
V
Every API uses accessToken in Authorization header
|
V
If API returns 401 Unauthorized:
  â†’ Automatically send a request to /auth/refresh
  â†’ Backend validates refreshToken from cookie
  â†’ Backend issues new accessToken
  â†’ Frontend retries original request


// Pseudocode
api.interceptors.response.use(null, async (error) => {
  const status = error.response?.status;
  const errorCode = error.response?.data?.error;

  if (status === 401 && errorCode === 'token_expired') {
    // Try refreshing token
    const refreshed = await refreshAccessToken();
    if (refreshed) {
      // retry original request
      return api.request(error.config);
    } else {
      logoutUser();
    }
  }

  if (status === 403 && errorCode === 'refresh_expired') {
    logoutUser();
  }

  return Promise.reject(error);
});
