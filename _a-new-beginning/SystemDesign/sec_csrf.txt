ğŸš© Understanding Cross-Site Requests, SOP, CORS & CSRF
ğŸŒ What is an Origin?

An origin is defined as a combination of:

protocol + domain + port


Example:

https://example.com:443  â†’ protocol=https, domain=example.com, port=443


Any difference in protocol, domain, or port means different origin.

ğŸ” Types of Cross-Site Requests
Type	Triggered By	Controlled By	Example
Non-Programmable (Passive)	HTML tags	CSP	<img src="...">, <link>, <script>
Programmable (Active)	JavaScript (fetch/XHR)	SOP + CORS	fetch('/api/data'), WebSocket
ğŸŸ¦ Non-Programmable Example (Passive)
<img src="https://other-site.com/logo.png" />


âœ… Browser allows the request unless blocked by CSP.

ğŸŸ¦ Programmable Example (Active)
fetch("https://api.other-site.com/data")


ğŸš« Browser blocks this by default due to Same-Origin Policy (SOP).

ğŸ›¡ Same-Origin Policy (SOP)

Prevents scripts from one origin from reading or modifying content on another origin.

Purpose: Stops a malicious site (evil.com) from accessing your private data on bank.com using JavaScript.

ğŸ”“ Cross-Origin Resource Sharing (CORS)

Since SOP is too restrictive, CORS is a server-side mechanism that selectively allows cross-origin requests.

How CORS Works:

Request with Origin header:

Origin: https://frontend.com


Server responds:

Access-Control-Allow-Origin: https://frontend.com


âœ… If it matches, browser allows the frontend code to read the response.
âŒ If not, the browser blocks the response for the script.

âš  About CSRF (Cross-Site Request Forgery)
ğŸ’¥ What is CSRF?

When a user is already authenticated with a site (via cookies), a malicious website tricks their browser into sending an unintended request with those cookies automatically attached.

In short: Browser automatically attaches cookies for a domain, even if request is triggered from another domain â€” and thatâ€™s the exploit.

ğŸª How Browser Treats Cookies

Cookies are tied to their target domain, NOT to the page making the request.

âœ” If your browser holds cookies for bank.com,
âœ” and you are on evil.com,
âœ” and a form is submitted to bank.com,

â¡ Your browser still attaches the cookies belonging to bank.com.

ğŸ”„ Demonstrating CSRF (Vulnerable Cookie-Based Auth)
âœ… Vulnerable Backend
res.cookie("session", "USER_SESS_ABC", { httpOnly: true, sameSite: "lax" });

app.post("/api/transfer", (req, res) => {
  const session = req.cookies.session; // Automatically sent by browser
  if (!session) return res.status(401).json({ error: "not authenticated" });
  console.log("TRANSFER EXECUTED");
  res.json({ transferred: true });
});

ğŸ˜ˆ Attacker Page
<form action="http://localhost:5000/api/transfer" method="POST">
  <input type="hidden" name="amount" value="1000">
</form>
<script>document.forms[0].submit();</script>


ğŸ”¥ As soon as this page loads, the browser automatically includes the victimâ€™s session cookie to localhost:5000, even though the user is on another origin.

âœ… SameSite Cookie Attribute: Preventing CSRF
SameSite Value	Sent in Top-Level GET Navigation	Sent in POST (Form/Fetch)	Typical Use
Strict	âœ… Yes (only from same site)	âŒ No	Max security
Lax (default)	âœ… Yes (for GET only)	âŒ No (blocks most CSRF)	Good default
None	âœ… Yes	âœ… Yes	When using third-party cookies (must be Secure)
ğŸ” What is Top-Level Navigation?

A navigation that replaces the current page in the browser:

Clicking a <a href> link

window.location = 'https://example.com'

302 redirects

It is NOT:

Form POST submission

XHR/fetch requests

Iframe requests

ğŸ“Œ Example with SameSite=Lax:

âœ… Cookie IS sent:

<!-- GET top-level navigation (allowed under Lax) -->
<a href="https://bank.com/profile">Go to profile</a>


âŒ Cookie NOT sent:

<!-- POST form (blocked under Lax) -->
<form action="https://bank.com/api/transfer" method="POST">
  <button type="submit">Send Money</button>
</form>

ğŸ”‘ Why JWT in Authorization Header Prevents CSRF

âœ… Browser never automatically attaches Authorization header
âœ… Only your own JS can attach it intentionally
ğŸš« Malicious websites cannot read your localStorage or memory (Same-Origin Policy)
ğŸš« Malicious <form> or <img> cannot set Authorization headers

So attacker cannot create a valid authenticated request unless they steal the token (which is XSS, not CSRF).

ğŸ¯ Final Security Posture Summary
Technique	Vulnerable to CSRF?	Why
Cookies (no SameSite, no CSRF token)	ğŸ”´ Yes	Browser auto-sends cookie
Cookies with SameSite=Lax	ğŸŸ¡ Mostly safe	Blocks POST-based CSRF
Cookies with SameSite=Strict	âœ… Very safe	Sent only if same-site
JWT in Authorization Header	âœ… Safe from CSRF	Browser never auto-attaches header
Cookies with SameSite=None + Secure + CSRF token	âœ… Safe	Industry-standard solution

Lax
How Does the Browser Know If It Was a Click or a Hidden Request?

The browser knows based on how the request was triggered.

âœ… User-Initiated Actions (Allowed in SameSite=Lax):

These all involve visible, explicit user interaction:

Clicking a normal <a href="https://bank.com">Visit Bank</a> link

Typing a URL into the browser address bar

Using a bookmark

Clicking a browser redirect, like from Google search results

â¡ï¸ The request is treated as a "navigation" initiated by the user
â¡ï¸ Cookies are sent

âŒ Hidden or Automatic Actions (Blocked in SameSite=Lax):

These happen without your knowledge or visible intent:

<img src="https://bank.com/api/transfer">

<form action="https://bank.com" method="POST"> that auto-submits via JS

fetch("https://bank.com/api") from JavaScript

<iframe src="https://bank.com">

â¡ï¸ Not considered user navigation
â¡ï¸ Cookies are not sent

Browser attaches cookies only when you are clearly going to a new page yourself.
Not when a script tries to make your browser send a sneaky request in the background.

The browser knows itâ€™s a link click because it tracks the source of the request. If it is a direct navigation triggered by user interaction (like clicking a visible link), it allows cookies. If it's a resource load or scripted request, it blocks cookies under SameSite=Lax.

âœ… Allowed (User Intentionally Clicked)

Examples:

You are on Google.com and click a link to Bank.com.

You are on Attacker.com and click a link that visibly takes you to Bank.com (you know you're going to Bank.com).

ğŸ‘‰ In both cases, the cookie IS sent.

Because you initiated the navigation by clicking a link.

ğŸŒŸ Lax allows cookies when you clearly navigate to the site.

â›” BLOCKED (Attacker Tries to Trigger Request Behind the Scenes)

Examples:

Attacker.com runs this in background:

<img src="https://bank.com/transfer?to=hacker&amount=10000" />


Or a hidden form auto-submits to Bank.com without your action.

Or JavaScript triggers a fetch or POST request to Bank.com automatically.

ğŸ‘‰ In all these cases you didnâ€™t actually click anything to visit Bank.com, so the cookie is NOT sent.

ğŸŒŸ Lax blocks cookies when the user didn't explicitly choose to go to the site.







































A cross-site request (also called a cross-origin request) is simply any request made by a client (like your browser) to a resource (like an API, an image, or a font) that resides on an origin different from the origin that served the current web page.
An origin is defined by the combination of its protocol, domain name, and port number.





Non-Programmable Requests (Passive)
These are resource requests made directly by HTML tags, not by JavaScript code.

Examples: Loading an image (<img src="...">), a stylesheet (<link rel="stylesheet"...>), or a font (@font-face).

Security Check: These requests are typically allowed by default across origins. Their primary security control is CSP.

In your current csp_server.js example, loading the image from https://placehold.co is this type of request, and it is blocked by your strict default-src 'self' CSP policy.



Programmable Requests (Active)
These are requests initiated by JavaScript to actively fetch or send data.

Examples: fetch('/api/data'), XMLHttpRequest, or making a WebSocket connection.

Security Check: These requests are governed by the Same-Origin Policy (SOP), which is then relaxed by CORS if the remote server agrees.

In your current csp_server.js example, the fetch('/api/products') call succeeds because it's a same-origin request (localhost:3000 to localhost:3000), so CORS is not involved


Same-Origin Policy (SOP)
The SOP is a critical security mechanism that dictates:

A document or script loaded from one origin cannot interact with a resource from another origin.
Why? To prevent a malicious script running on https://evil.com from making a programmatic request to https://mybank.com and reading your private data (e.g., balance details).


Cross-Origin Resource Sharing (CORS)
Since modern apps must communicate across origins (e.g., your front end on app.com needs to call your API on api.app.com), the SOP is too strict. CORS is the mechanism that allows the server to explicitly grant permission to specific external origins to access its data.

When a script on Origin A tries to access Origin B, the browser checks the response headers from Origin B:

Request Header: Browser adds an Origin: https://origin-A.com header to the request.

Response Header: The server at Origin B must respond with:

Access-Control-Allow-Origin: https://origin-A.com
Result: If the origins match, the browser allows the script to read the response data. If it doesn't match, the browser blocks the script from reading the data (it's a CORS violation).


Summary of Cross-Site Requests and Security:
Request Type                           Security Enforced 
ByImages, Fonts, Scripts (Loading)     CSP (Content Security Policy)
AJAX/Fetch (Data Retrieval)            CORS (Cross-Origin Resource Sharing)



1) Why JWT in Authorization header is not vulnerable to CSRF â€” one line

Browsers automatically send cookies with cross-site requests; they do not automatically add custom headers like Authorization. An attacker can make your browser request another site, but cannot force it to attach a secret header it didn't create in page JS. Therefore, auth that relies on a header must be set by your JS (not sent implicitly), so CSRF can't silently use it.


// vuln-server.js
import express from "express";
import cookieParser from "cookie-parser";

const app = express();
app.use(express.json());
app.use(cookieParser());

// simple "login" that sets a cookie (simulate authentication)
app.post("/login", (req, res) => {
  // no real creds here for brevity
  // cookie is set for example.com: it will be sent automatically with later requests
  res.cookie("session", "USER_SESS_ABC", { sameSite: "lax" /* demo */, httpOnly: true });
  return res.json({ ok: true });
});

// Protected action that requires cookie auth
app.post("/api/transfer", (req, res) => {
  const sess = req.cookies.session;
  if (!sess) return res.status(401).json({ error: "not authenticated" });

  // Do the sensitive action (transfer money, delete account, etc)
  console.log("TRANSFER EXECUTED by session:", sess);
  return res.json({ ok: true, transferred: true });
});

app.listen(5000, () => console.log("Vulnerable server listening on http://localhost:5000"));



Attacker HTML page (host this on another origin, e.g. open file or run on :4000)
Save as attacker.html and open it in browser (file:// or a small server).
<!doctype html>
<html>
  <body>
    <h3>Malicious page</h3>

    <!-- A simple form that will POST to the victim server.
         When the victim visits this page, the browser will submit
         the form and *automatically include cookies for localhost:5000*. -->
    <form id="f" action="http://localhost:5000/api/transfer" method="POST">
      <input type="hidden" name="amount" value="1000" />
    </form>
    <script>
      // auto-submit â€” victim's browser will send cookies to localhost:5000 automatically
      document.getElementById('f').submit();
    </script>
  </body>
</html>

3) Why the same attack fails when you require Authorization: Bearer <token> header
Safe server that expects header
Save as safe-server.js and run node safe-server.js.
// safe-server.js
import express from "express";
import cors from "cors";

const app = express();
app.use(express.json());
app.use(cors());

// login returns a token to the client (not set as cookie)
app.post("/login", (req, res) => {
  // normally sign JWT. here we return a fake token
  res.json({ accessToken: "FAKE_TOKEN_123" });
});

// Protected endpoint expects Authorization header
app.post("/api/transfer", (req, res) => {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith("Bearer ")) return res.status(401).json({ error: "no auth header" });

  const token = auth.slice(7);
  // verify token... skipped for brevity
  console.log("Transfer executed using token:", token);
  res.json({ ok: true });
});

app.listen(5001, () => console.log("Safe server listening on http://localhost:5001"));


Attacker page trying the same trick (open in browser)
<!doctype html>
<html>
  <body>
    <h3>Malicious page trying to set header</h3>

    <script>
      // This fetch attempts to call the protected endpoint CROSS-ORIGIN.
      // Note: you cannot make the browser automatically include a custom Authorization header
      // for a cross-origin form submission; only JS can set headers â€” but attacker JS runs on attacker's origin,
      // so it cannot read victim's stored token and therefore cannot set the correct Authorization header.
      fetch("http://localhost:5001/api/transfer", { method: "POST", body: JSON.stringify({amount:1000}), headers: { "Content-Type": "application/json" }})
        .then(r => r.text())
        .then(console.log)
        .catch(console.error);
    </script>
  </body>
</html>


Why this fails for the attacker

The attacker cannot know the victimâ€™s JWT token stored in the victimâ€™s JavaScript memory or localStorage.

The browser will not magically attach an Authorization header containing the victimâ€™s token â€” only the victimâ€™s own site JS can set that header.

If the attacker attempts to use fetch and set Authorization themselves, they would have to know the secret token. They don't.

Note about CORS: even if attacker tries to send a fetch with a custom header, the browser will preflight and the server must return Access-Control-Allow-Origin and Access-Control-Allow-Headers for the request to go through â€” servers normally don't allow arbitrary origins to set Authorization.


JWT in Authorization header prevents CSRF because browsers do not automatically attach custom headers to cross-site requests.

A malicious site cannot force the victimâ€™s browser to add the victimâ€™s JWT to an Authorization header unless that site can first read the JWT from the victim (which it cannot, thanks to the same-origin policy) or the token is stored in a browser place the attacker can access (e.g., global JS on victim site â€” i.e., XSS).

CORS and prefight protect servers from cross-origin JavaScript reading responses or sending non-simple requests unless the server explicitly allows it.


1) Attacker tries a plain GET to your API (no Authorization header)
// attacker page (attacker.com)
fetch("https://api.yoursite.com/protected") // no auth header
  .then(r => r.text()).then(console.log);


What happens: Browser issues request but no Authorization header is present, so server responds 401 or 403.

CORS: Even if server responded, the browser will only expose the response to attacker JS if the server sets Access-Control-Allow-Origin: attacker.com (or *). A correctly-configured API will not allow that for protected endpoints.

â†’ Attacker gets nothing.


2) Attacker tries to make victim's browser send a request with an Authorization header

Attacker cannot cause the browser to add a header that only the victim app can generate. The only way to set Authorization: Bearer <token> from attacker origin is if attacker JS has the token value â€” which it does not.

You might ask: â€œCan attacker JS set Authorization to some random value and hope it works?â€ â€” yes, but it will be rejected because token is invalid.

Role of CORS â€” succinctly

CORS prevents cross-origin JS from reading responses or sending certain headers unless the server opts in.

A simple GET request wonâ€™t include Authorization (so preflight is not relevant). But it also wonâ€™t be authenticated, so server returns 401.

A request with custom header (like Authorization) requires preflight; the server must explicitly accept the origin and header to allow it. If it doesnâ€™t, browser blocks it.

Final concise checklist (security posture)

âœ… Store JWT in memory or send it to client and keep it in memory; then client sets Authorization header on requests â†’ prevents CSRF, but be careful with XSS.
âœ… Donâ€™t put JWT in cookies unless you also implement CSRF protection (SameSite, double-submit token, csurf).
âœ… Use CORS properly: only allow origins you trust, and donâ€™t allow Authorization header for arbitrary origins.
âœ… Treat XSS as the big risk when auth relies on client-side accessible tokens â€” sanitize, CSP, HttpOnly where possible.



1) When does a preflight (OPTIONS) request trigger?

A preflight happens when a cross-origin fetch/XHR uses a non-simple request. The browser sends an OPTIONS to ask the server â€œis this allowed?â€ before the real request.

Triggers (any of these):

HTTP method is not GET, HEAD, or POST (e.g. PUT, DELETE, PATCH).

OR request uses custom headers (like Authorization, X-My-Header), i.e. any header other than the simple ones (Accept, Accept-Language, Content-Language, Content-Type with restricted values).

OR Content-Type is not one of application/x-www-form-urlencoded, multipart/form-data, or text/plain.

Example:

// triggers preflight because of Authorization header
fetch("https://api.example.com/protected", {
  method: "GET",
  headers: { "Authorization": "Bearer ..."}
});
// Browser will first send OPTIONS to https://api.example.com


Result: If server responds with appropriate CORS headers (Access-Control-Allow-Origin, Access-Control-Allow-Headers, etc.), browser proceeds; otherwise it blocks the real request.


Yes â€” the browser can attach cookies to requests to origin A even when the user is viewing a page from origin B. Cookies are tied to the request target domain â€” not the current page domain.
So even though the attacker page is on attacker.com, the browser attaches cookies to the request because the request target is victim.com.


Quick summary + mental model

Cookies belong to the target origin. Any browser request to that origin (form, image, script, fetch with credentials) will include cookies for that origin â€” irrespective of the page origin.
CSRF leverages this automatic sending to make the victimâ€™s browser perform authenticated actions unknowingly.
JWT in Authorization header avoids CSRF because cookies arenâ€™t involved and custom headers arenâ€™t auto-attached. But this pushes you to protect against XSS (because if an attacker runs script on your page they can read token in JS).
SameSite=Lax blocks a large class of classic CSRF form attacks (recommended default).
Best practice for cookie-based auth: use SameSite=Lax/Strict + HttpOnly + CSRF tokens (double-submit or csurf) + origin checks.