Tips:
Features (MVP, core functionality)
NFR (performance, offline mode, security, high availability)
UX (Accessibility, User friendly)
Backend APIS
Engineering

https://www.youtube.com/watch?v=ixee55xm_d8



Instagram feed
Features
1. image or text post 1mb image
2. comment, share and like button

1mil user per day, 1 daily post per day per user/ 100 views per user - read/write
most active time  70% active user during evening peak time

100 read * 7lakh user / 2hours = rps
throughput issue (a user might see 100 image post hence 100 image download over an hour maybe)


Webapp => feed service => ImageBlobStorage(with CDN) <= Webapp
So feed service will provide image address and it will be fetched from imageblob storage 

n rps => CDN => Webapp => BE

Webapp => read service with load balancer
Webapp => write service 

DB [NoSql like mongo] if shape of the data is independent and less complex we can go with noSql other mysql could be could
Redis can come in between webapp and readservice

for large infinite scroll, DOM optimisation is important.
we can unmount post outside the viewport
use virtualised list
cursor based pagination linked with intersection observer

if the interaction is high or highly stateful, csr is better than ssr


Micro frontend architecture:
Advantage:
Scalability
Reliability
Tech agnostic
dedicated ci/cd pipeline


Disadvantage
Excessive coupling increasing complexity
Increase cost due to multiple pipeline


Connection:
app1:
new ModuleFederationPlugin({
    name: 'app1',
    fileName: 'remoteEntry.js', [all exposable modules will be listed here]
    expose: {
        "./App": "./src/App"
    }
})

app2:
new ModuleFederationPlugin({
    name: 'app2',
    fileName: 'remoteEntry.js', [all exposable modules will be listed here]
    expose: {},
    remotes: {
        app1: "app1@http://localhost:8083/remoteEntry.js"
    }
})

import Button = React.lazy(( ) => import("app1/Button"))
